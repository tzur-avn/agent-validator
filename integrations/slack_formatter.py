"""Slack message formatter for agent results."""

import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class SlackFormatter:
    """Format agent results for Slack display."""

    def format_agent_result(self, result: Dict[str, Any]) -> Any:
        """
        Format agent result for Slack.

        Args:
            result: Agent result dictionary

        Returns:
            Slack message blocks (dict) or text (str)
        """
        agent_name = result.get("agent", "Unknown")
        url = result.get("url", "")
        report = result.get("report", "")

        # Parse the report based on agent type
        if "spell" in agent_name.lower():
            return self._format_spell_checker_result(result)
        elif "visual" in agent_name.lower():
            return self._format_visual_qa_result(result)
        else:
            return self._format_generic_result(result)

    def _format_spell_checker_result(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Format spell checker results for Slack.

        Args:
            result: Spell checker result

        Returns:
            Slack message with blocks
        """
        url = result.get("url", "")
        report = result.get("report", "")
        errors = result.get("errors", [])

        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "âœï¸ Spell Checker Report",
                    "emoji": True,
                },
            },
            {"type": "section", "text": {"type": "mrkdwn", "text": f"*URL:* {url}"}},
            {"type": "divider"},
        ]

        if errors and len(errors) > 0:
            blocks.append(
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Found {len(errors)} issue(s):*",
                    },
                }
            )

            # Add first few errors (limit to avoid message size issues)
            for i, error in enumerate(errors[:10], 1):
                original = error.get("original", "")
                correction = error.get("correction", "")
                context = error.get("context", "")

                error_text = f"*{i}.* `{original}` â†’ `{correction}`"
                if context:
                    error_text += f"\n   _Context:_ {context[:100]}..."

                blocks.append(
                    {"type": "section", "text": {"type": "mrkdwn", "text": error_text}}
                )

            if len(errors) > 10:
                blocks.append(
                    {
                        "type": "context",
                        "elements": [
                            {
                                "type": "mrkdwn",
                                "text": f"_...and {len(errors) - 10} more issues_",
                            }
                        ],
                    }
                )
        else:
            blocks.append(
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": "âœ… *No spelling or grammar issues found!*",
                    },
                }
            )

        # Add summary
        blocks.append({"type": "divider"})
        blocks.append(
            {
                "type": "context",
                "elements": [
                    {"type": "mrkdwn", "text": f"Report generated by Agent Validator"}
                ],
            }
        )

        return {"blocks": blocks}

    def _format_visual_qa_result(self, result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Format visual QA results for Slack.

        Args:
            result: Visual QA result

        Returns:
            Slack message with blocks
        """
        url = result.get("url", "")
        report = result.get("report", "")
        issues = result.get("issues", [])

        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "ðŸ‘ï¸ Visual QA Report",
                    "emoji": True,
                },
            },
            {"type": "section", "text": {"type": "mrkdwn", "text": f"*URL:* {url}"}},
            {"type": "divider"},
        ]

        if issues and len(issues) > 0:
            blocks.append(
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Found {len(issues)} visual issue(s):*",
                    },
                }
            )

            # Add first few issues
            for i, issue in enumerate(issues[:10], 1):
                severity = issue.get("severity", "medium")
                description = issue.get("description", "")
                element = issue.get("element", "")

                # Map severity to emoji
                severity_emoji = {"high": "ðŸ”´", "medium": "ðŸŸ¡", "low": "ðŸŸ¢"}.get(
                    severity.lower(), "âšª"
                )

                issue_text = f"{severity_emoji} *{i}.* {description}"
                if element:
                    issue_text += f"\n   _Element:_ `{element}`"

                blocks.append(
                    {"type": "section", "text": {"type": "mrkdwn", "text": issue_text}}
                )

            if len(issues) > 10:
                blocks.append(
                    {
                        "type": "context",
                        "elements": [
                            {
                                "type": "mrkdwn",
                                "text": f"_...and {len(issues) - 10} more issues_",
                            }
                        ],
                    }
                )
        else:
            blocks.append(
                {
                    "type": "section",
                    "text": {"type": "mrkdwn", "text": "âœ… *No visual issues found!*"},
                }
            )

        # Add summary
        blocks.append({"type": "divider"})
        blocks.append(
            {
                "type": "context",
                "elements": [
                    {"type": "mrkdwn", "text": "Report generated by Agent Validator"}
                ],
            }
        )

        return {"blocks": blocks}

    def _format_generic_result(self, result: Dict[str, Any]) -> str:
        """
        Format generic agent result.

        Args:
            result: Agent result

        Returns:
            Formatted text
        """
        agent_name = result.get("agent", "Unknown")
        url = result.get("url", "")
        report = result.get("report", "No report available")

        text = f"*{agent_name} Report*\n\n"
        text += f"*URL:* {url}\n\n"
        text += f"*Result:*\n{report}"

        return text

    @staticmethod
    def format_error(error: str) -> str:
        """
        Format error message for Slack.

        Args:
            error: Error message

        Returns:
            Formatted error
        """
        return f"âŒ *Error:* {error}"

    @staticmethod
    def format_success(message: str) -> str:
        """
        Format success message for Slack.

        Args:
            message: Success message

        Returns:
            Formatted success
        """
        return f"âœ… {message}"
